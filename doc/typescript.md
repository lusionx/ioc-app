typescript 语法实践
=======================
### 基本经历
从 v1 开始解除, 到 v3 开始大规模使用, 并逐渐每个 3.x 版本跟进升级过来, 3年经验

我早年做 C# 开发, 之后接触 js, 从工作中总结如果权衡动态与静态

目标是写简单易懂, 健壮的代码, 不炫技, 有时可能故意写的很冗余

## 禁止使用

请抛弃文件/路径名在运行时的意义, 仅作为帮人组织代码的注解

### 禁 require 函数

es5 的遗留问题, 尤其是require(变量), 属于历史糟粕; 应该尽可能的向静态靠拢, 也符合 es6 的标准

> 和 default 关联

### 禁 export default

这个语法的出现是因为解释器必须兼容历史包, 在新写的代码里不该出现这个

> 有些框架要求代码业务实现需要用 default, 是因为把这东西当成了 js 里唯一的真接口 {default:any}; 这种情况下只能向框架妥协
> 在自己的代码里应该把 export 的东西给一个合理的名字, 哪怕是 `main`, 而且除了真正的实现, 大概率还会 export 接口/类型, 起名很重要

### 禁 lodash 包

这个包的内部实现大量使用了 js 的`类反射`特性, 导致不能推断类型
```
let k = 'xxx'
obj.k === obj[k]
```
> 关联`动态字段`的问题

### async 包
请使用原生的`promise`代替

`while/for` 的关键字里正常使用 `await`; `eslint`默认禁止这种情况是因为从性能角度可以并发执行, 在实际代码中请按需使用

## 舍弃动态

### 动态字段

如果目的是 clone, 可以使用解构`{...data}`或`Object.assign`

其他情况请使用最笨的赋值语句, 然后按需建接口, 除了第一次写的时候代码多些, 但之后读代码的时候可以一目十行过代码, 无需思考

### 函数返回值

参数的重载按照正常的默认值使用, 但不要把返回值弄成多种类型, 因为这样就逼迫调用方去做类型判断

> 甚至需要考虑可空类型`number?`真的是空时, 是否应该抛异常

### 高阶函数

参考典型的`Array.map`, 使用类型确定的函数, 最次该是是带泛型的 `() => T` 匿名函数, 只有这样才能将类型传递下去

### 装饰器

保持黑盒, 内部使用 any,

## PS

程序 = 数据 + 算法

用 ts 的目的是利用静态编译, 保证数据在计算过程中的稳定, 不会出现undefined, 而一旦发现 `undefined` 能定位到一定是实际的数据与接口不符合导致的

算法部分, 只需要少量的测试即可
